#include "./L1JetAnalysis.hh"
// --------------------------------------------------------------------
//                       L1JetAnalysis macro definition
//
//    macro automatically generated by GenerateMacro.sh script
//    author           : bm409
//    creation date    : Sat Oct 23 14:00:25 CEST 2010
//    last update date :
//    description      :
//
// --------------------------------------------------------------------


// --------------------------------------------------------------------
//                             run function
// --------------------------------------------------------------------

void L1JetAnalysis::BookHistos() {

  RefJets = new TH1F("RefJet", "RefJetEt",1000,0.,1000);
  Bit15   = new TH1F("Bit15", "JetEt",1000,0.,1000);
  Bit16   = new TH1F("Bit16", "JetEt",1000,0.,1000);
  Bit17   = new TH1F("Bit17", "JetEt",1000,0.,1000);
  Bit18   = new TH1F("Bit18", "JetEt",1000,0.,1000);
  Bit19   = new TH1F("Bit19", "JetEt",1000,0.,1000);
  Bit20   = new TH1F("Bit20", "JetEt",1000,0.,1000);
  Bit21   = new TH1F("Bit21", "JetEt",1000,0.,1000);
  l1JetEn = new TH1F("L1Energy", "L1Et",1000,0.,1000.);
// CandidateJets30Gev = new TH1F("RefJet", "RefJetEt",200,0.,1000);
  RecoVsl1HFE       = new TH2F(     "RecoVsl1HFE",    "Offline Uncorrected Jet Et; L1 Jet Et",1000,0.,1000.,1000,0.,1000);
  ResolutionEtHFE   = new TH2F( "ResolutionEtHFE","RecoJetEt;(Reco Jet Et - L1 Jet Et) / Reco Jet Et",500.,0.,500.,200,-10.,10);
  ResolutionHFE     = new TH1F(   "ResolutionHFE",  "(Reco Jet Et - L1 Jet Et) / Reco Jet Et",200,-10.,10);
  RecoVsl1HFH       = new TH2F(     "RecoVsl1HFH",    "Offline Uncorrected Jet Et; L1 Jet Et",1000,0.,1000.,1000,0.,1000);
  ResolutionEtHFH   = new TH2F( "ResolutionEtHFH","RecoJetEt;(Reco Jet Et - L1 Jet Et) / Reco Jet Et",500.,0.,500.,200,-10.,10);
  ResolutionHFH     = new TH1F(   "ResolutionHFH",  "(Reco Jet Et - L1 Jet Et) / Reco Jet Et",200,-10.,10);
  ResolutionHE      = new TH1F(    "ResolutionHE",   "(Reco Jet Et - L1 Jet Et) / Reco Jet Et",200,-10.,10);
  ResolutionEtHE    = new TH2F(  "ResolutionEtHE", "RecoJetEt;(Reco Jet Et - L1 Jet Et) / Reco Jet Et",500.,0.,500.,200,-10.,10);
  RecoVsl1HE        = new TH2F(      "RecoVsl1HE",     "Offline Uncorrected Jet Et; L1 Jet Et",1000,0.,1000.,1000,0.,1000);
  ResolutionEE      = new TH1F(    "ResolutionEE",   "(Reco Jet Et - L1 Jet Et) / Reco Jet Et",200,-10.,10);
  ResolutionEtEE    = new TH2F(  "ResolutionEtEE", "RecoJetEt;(Reco Jet Et - L1 Jet Et) / Reco Jet Et",500.,0.,500.,200,-10.,10);
  RecoVsl1EE        = new TH2F(      "RecoVsl1EE",     "Offline Uncorrected Jet Et; L1 Jet Et",1000,0.,1000.,1000,0.,1000);
  ResolutionHB      = new TH1F(    "ResolutionHB",   "(Reco Jet Et - L1 Jet Et) / Reco Jet Et",200,-10.,10);
  ResolutionEtHB    = new TH2F(  "ResolutionEtHB", "RecoJetEt;(Reco Jet Et - L1 Jet Et) / Reco Jet Et",500.,0.,500.,200,-10.,10);
  RecoVsl1HB        = new TH2F(      "RecoVsl1HB",     "Offline Uncorrected Jet Et; L1 Jet Et",1000,0.,1000.,1000,0.,1000);
  ResolutionEB      = new TH1F(    "ResolutionEB",   "(Reco Jet Et - L1 Jet Et) / Reco Jet Et",200,-10.,10);
  ResolutionEtEB    = new TH2F(  "ResolutionEtEB", "RecoJetEt;(Reco Jet Et - L1 Jet Et) / Reco Jet Et",500.,0.,500.,200,-10.,10);
  RecoVsl1EB        = new TH2F(      "RecoVsl1EB",     "Offline Uncorrected Jet Et; L1 Jet Et",1000,0.,1000.,1000,0.,1000);
  EMF               = new TH1F(  "EMF","Jet[0] FEM",100,-1.,1.);
  timeMap           = new TH2I("Bits", "Bunch Crossing vs trigger bit", 130, 0., 130., 10, 0., 10.);
  ResolutionAsFnOfpT = new TH2F("ResolutionAsFnOfpT"," ; L1 P_{T};(Reco Jet Et - L1 Jet Et) / Reco Jet Et",30,0.,300.,200,-10.,10.);
  ResolutionAsFnOfeta = new TH2F("ResolutionAsFnOfeta"," ; L1 #eta;(Reco Jet Et - L1 Jet Et) / Reco Jet Et",20,-5.,5.,200,-10.,10.);
}

// --------------------------------------------------------------------
//                             run function
// --------------------------------------------------------------------
  void L1JetAnalysis::run(Long64_t nevents, TString outputname, bool UnCorThresholds, TString TriggerBit) //To run use m.run(events,"SomeoutputName")
  {
    //Book Histos
    BookHistos();
    //load TDR style
    TFile *theFile = new TFile(outputname, "RECREATE");
    theFile->cd();
    //number of events to process
    if (nevents==-1 || nevents>GetEntries()) nevents=GetEntries();
    std::cout << nevents  << " to process ..." << std::endl;
    //loop over the events
    for (Long64_t i= 0; i<   nevents; i++)
    {
      //load the i-th event
      Long64_t ientry = LoadTree(i); if (ientry < 0) break;
      GetEntry(i);
      //process progress
      if( i!=0 && ( i%1000 ) ==0 ) {std::cout << "- processing event " << i << "\r" << std::flush;}
      double wgt =1.0;
      // Check that we have jets in the event.
      if((recoJet_->et).size() < 1) continue;
      // Trigger stuff
      if (!TriggerBit.IsWhitespace() && !PassHLT(TriggerBit) ) continue;
      // Selection for the turn on curves

      //  NB a bit of a hack to read out the correct value from the ReturnMatchedQuantity function -- Didnt know about Enums at the time, will re-write when there is time
      int Et = 1;

      if(recoJet_->etCorr[0]>2. && fabs(recoJet_->eta[0])< 2.6 && LooseID(0) ){ // check leading recoJet is with in barrel and has et>2GeV
      std::pair <int,int> matchedJet = ReturnMatchedJet(0); // Try to match a L1 Jet to the zeroth reco Jet, return the l1 type and l1 index of
      //cout << " Match jet is : " << matchedJet.first << " " << matchedJet.second << endl;
      //cout << " Matched Jet Pt is : " << ReturnMatchedQuantity(matchedJet,1) << " Offline Jet ET " << recoJet_->etCorr[0] << endl;
      if(!MatchJet(0)) continue;
      RefJets->Fill(recoJet_->etCorr[0],wgt); // Denominator for turn on curves
      if( UnCorThresholds ){
        // Ask for old UnCorThresholds -- Use on the 2010 Data
        if(ReturnMatchedQuantity(matchedJet,Et)> 6.){  Bit15      ->Fill(recoJet_->etCorr[0],wgt); } // now goes to SingleJet16
        if(ReturnMatchedQuantity(matchedJet,Et)> 10.){ Bit16      ->Fill(recoJet_->etCorr[0],wgt); } // now goes to SingleJet36
        if(ReturnMatchedQuantity(matchedJet,Et)> 20.){ Bit17      ->Fill(recoJet_->etCorr[0],wgt); } // now goes to SingleJet52
        if(ReturnMatchedQuantity(matchedJet,Et)> 30.){ Bit18      ->Fill(recoJet_->etCorr[0],wgt); } // now goes to SingleJet68
        if(ReturnMatchedQuantity(matchedJet,Et)> 40.){ Bit19      ->Fill(recoJet_->etCorr[0],wgt); } // now goes to SingleJet92
        if(ReturnMatchedQuantity(matchedJet,Et)> 60.){ Bit20      ->Fill(recoJet_->etCorr[0],wgt); } // now goes to SingleJet128
      }
      else{
        // Ask for Corrected L1 Jets -- Use on 2011 Data
        if(ReturnMatchedQuantity(matchedJet,Et)> 16.){ Bit15      ->Fill(recoJet_->etCorr[0],wgt); } // now goes to SingleJet16
        if(ReturnMatchedQuantity(matchedJet,Et)> 20.){ Bit16      ->Fill(recoJet_->etCorr[0],wgt); } // now goes to SingleJet36
        if(ReturnMatchedQuantity(matchedJet,Et)> 36.){ Bit17      ->Fill(recoJet_->etCorr[0],wgt); } // now goes to SingleJet52
        if(ReturnMatchedQuantity(matchedJet,Et)> 52.){ Bit18      ->Fill(recoJet_->etCorr[0],wgt); } // now goes to SingleJet68
        if(ReturnMatchedQuantity(matchedJet,Et)> 68.){ Bit19      ->Fill(recoJet_->etCorr[0],wgt); } // now goes to SingleJet92
        if(ReturnMatchedQuantity(matchedJet,Et)> 92.){ Bit20      ->Fill(recoJet_->etCorr[0],wgt); } // now goes to SingleJet128
      }

    }
    //Make a plot of the 0th L1 Jet energy
    l1JetEn->Fill(MaxL1Et(),wgt);
    // Note that for the resolution studies we can use more than the leading jet -- enter different loop
    for(size_t j = 0 ; j < recoJet_->et.size(); ++j)
    {
      if ( !LooseID(j) ) continue;
      if( MatchJet(j) ){
          // barrel jets
        std::pair <int,int> matchedJetLoop = ReturnMatchedJet(j); // Try to match a L1 Jet to the jth reco Jet, return the l1 type and index of L1Jet
        EMF->Fill(recoJet_->eEMF[j],2);
        ResolutionAsFnOfeta->Fill(recoJet_->eta[j], (recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJetLoop,Et))/recoJet_->etCorr[j],wgt);
        ResolutionAsFnOfpT->Fill(recoJet_->etCorr[j], (recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJetLoop,Et))/recoJet_->etCorr[j],wgt);

        if( fabs(recoJet_->eta[j]) < 1.3 ){
          if(recoJet_->eEMF[j] > 0.9){
            RecoVsl1EB->Fill(recoJet_->etCorr[j],ReturnMatchedQuantity(matchedJetLoop,Et),wgt);
            ResolutionEtEB->Fill(recoJet_->etCorr[j], (recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJetLoop,Et))/recoJet_->etCorr[j],wgt);
            ResolutionEB->Fill((recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJetLoop,Et))/recoJet_->etCorr[j],wgt);
          }
          if(recoJet_->eEMF[j] < 0.4){
            RecoVsl1HB->Fill(recoJet_->etCorr[j],ReturnMatchedQuantity(matchedJetLoop,Et),wgt);
            ResolutionEtHB->Fill(recoJet_->etCorr[j], (recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJetLoop,Et))/recoJet_->etCorr[j],wgt);
            ResolutionHB->Fill((recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJetLoop,Et))/recoJet_->etCorr[j],wgt);
          }
        }
              //endcap jets
        if(fabs(recoJet_->eta[j]) > 1.3 && fabs(recoJet_->eta[j]) < 3.0){
          if(recoJet_->eEMF[j] > 0.9){
            RecoVsl1EE->Fill(recoJet_->etCorr[j],ReturnMatchedQuantity(matchedJetLoop,Et),wgt);
            ResolutionEtEE->Fill(recoJet_->etCorr[j], (recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJetLoop,Et))/recoJet_->etCorr[j],wgt);
            ResolutionEE->Fill((recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJetLoop,Et))/recoJet_->etCorr[j],wgt);
          }
          if(recoJet_->eEMF[j] < 0.4){
            RecoVsl1HE->Fill(recoJet_->etCorr[j],ReturnMatchedQuantity(matchedJetLoop,Et),wgt);
            ResolutionEtHE->Fill(recoJet_->etCorr[j], (recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJetLoop,Et))/recoJet_->etCorr[j],wgt);
            ResolutionHE->Fill((recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJetLoop,Et))/recoJet_->etCorr[j],wgt);
          }

        }
      //forward jets
        if(fabs(recoJet_->eta[j]) > 3.0 ){
          if(recoJet_->eEMF[j] > 0.9){
            RecoVsl1HFE->Fill(recoJet_->etCorr[j],ReturnMatchedQuantity(matchedJetLoop,Et),wgt);
            ResolutionEtHFE->Fill(recoJet_->etCorr[j], (recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJetLoop,Et))/recoJet_->etCorr[j],wgt);
            ResolutionHFE->Fill((recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJetLoop,Et))/recoJet_->etCorr[j],wgt);
          }
          if(recoJet_->eEMF[j] < 0.4){
            RecoVsl1HFH->Fill(recoJet_->etCorr[j],ReturnMatchedQuantity(matchedJetLoop,Et),wgt);
            ResolutionEtHFH->Fill(recoJet_->etCorr[j], (recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJetLoop,Et))/recoJet_->etCorr[j],wgt);
            ResolutionHFH->Fill((recoJet_->etCorr[j]-ReturnMatchedQuantity(matchedJetLoop,Et))/recoJet_->etCorr[j],wgt);
          }

        }

      }
    }


    // Timing studies
      for(size_t bx = 0; bx < 5; ++bx)
      {
        for(size_t bit = 0; bit < 128; ++bit)
        {
          if(PassTrig(bit,bx)){
            timeMap->Fill(bit,bx,wgt);
          }
        }
      }
    }
    //  Write out the files so we can make eff curves etc - do this outside of the macro so we can run on the batch
    timeMap->Write();
    ResolutionHE->Write();
    ResolutionEtHE->Write();
    RecoVsl1HE->Write();
    ResolutionEE->Write();
    ResolutionEtEE->Write();
    RecoVsl1EE->Write();
    ResolutionHB->Write();
    ResolutionEtHB->Write();
    RecoVsl1HB->Write();
    ResolutionEB->Write();
    ResolutionEtEB->Write();
    RecoVsl1EB->Write();
    EMF->Write();
    ResolutionHFH->Write();
    ResolutionEtHFH->Write();
    RecoVsl1HFH->Write();
    ResolutionHFE->Write();
    ResolutionEtHFE->Write();
    RecoVsl1HFE->Write();
    Bit15->Write();
    Bit16->Write();
    Bit17->Write();
    Bit18->Write();
    Bit19->Write();
    Bit20->Write();
    Bit21->Write();
    RefJets->Write();
    ResolutionAsFnOfpT->Write();
    ResolutionAsFnOfeta->Write();
    l1JetEn->Write();
    // Write and close the file!
    theFile->Write();
    theFile->Close();
  }
